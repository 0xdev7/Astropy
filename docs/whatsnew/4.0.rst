.. _whatsnew-4.0:

**************************
What's New in Astropy 4.0?
**************************

Overview
========

Astropy 4.0 is a major release that ...  since
the 3.2.x series of releases.

In particular, this release includes:

* Major improvements in compatibility of Quantities with numpy functions
*

In addition to these major changes, Astropy v4.0 includes a large number of
smaller improvements and bug fixes, which are described in the
:ref:`changelog`. By the numbers:

* xxx issues have been closed since v3.2
* xxx pull requests have been merged since v3.2
* xxx distinct people have contributed code


Pre-publication Planck 2018 cosmological parameters
---------------------------------------------------

A pre-publication version of the Planck 2018 cosmological parameters
has been included based on version 2 of the submitted paper.  This
will be replaced with a final version when the paper is accepted.

.. doctest-requires:: scipy
  >>> from astropy.cosmology import Planck18_arXiv_v2
  >>> Planck18_arXiv_v2.age(0)  # doctest: +FLOAT_CMP
  <Quantity 13.7868853 Gyr>


New models
----------

.. Blackbody changes
.. Drude1D
.. Analytical King
.. Exponential1D and Logarithmic1D


Consistency of physical constants and units
-------------------------------------------

Physical constants and units using them are based on measurements that improve
and therefore not "constant" numerically.  Generally, one wants to just use
the latest values, but sometimes it helps to reproduce earlier results by
going back in time.  For that purpose, astropy 4.0 introduces the new
`~astropy.physical_constants` and `~astropy.astronomical_constants` science
state functions, which can be set to use previous versions.  For more details,
see `astropy-constants-prior`_.

Updates to Galactocentric frame
-------------------------------

Most coordinate frames implemented in :ref:`astropy.coordinates
<astropy-coordinates>` have standard parameters that are set by IAU consensus
(e.g., the ``ICRS`` frame). Unlike these, the
`~astropy.coordinates.Galactocentric` coordinate frame does not have an absolute
definition: Its parameters (the solar motion and position relative to the
Galactic center) are measurements that continue to be refined as newer stellar
surveys are executed and analyzed. When it was added, the default parameter
values used by the `~astropy.coordinates.Galactocentric` frame — i.e. the
parameter values assumed when defining a frame without explicitly setting
values, like ``galcen = Galactocentric()`` — were set to commonly-used values at
the time, but these are now somewhat out of date. With v4.0, we have added
functionality for globally controlling the default parameter values used by this
frame by setting the `~astropy.coordinates.galactocentric_frame_defaults` object
with the name of a parameter set. The parameter set names can currently be one
of ``"pre-v4.0"`` (to get the original, pre-version-4.0 values of the parameters),
``"v4.0"`` (to get a more modern set of values adopted in v4.0), and ``"latest"``
(which is currently an alias for ``"v4.0"`` and will always alias the most recent
set of parameters).

If your code depends sensitively on the choice of
`~astropy.coordinates.Galactocentric` frame parameters, make sure to explicitly
set the parameter set in your code, for example, after importing
:ref:`astropy.coordinates <astropy-coordinates>`::

    >>> import astropy.coordinates as coord
    >>> coord.galactocentric_frame_defaults.set('v4.0')  # doctest: +IGNORE_OUTPUT

The `~astropy.coordinates.Galactocentric` frame now also maintains a list of
references to scientific papers for the default values of the frame attributes.
For example, after adopting the v4.0 parameter set and defining a frame, we can
retrieve the references (as a dictionary of links to ADS) for the parameters
using the ``.frame_attribute_references`` attribute::

    >>> import astropy.coordinates as coord
    >>> coord.galactocentric_frame_defaults.set('v4.0')  # doctest: +IGNORE_OUTPUT
    >>> galcen = coord.Galactocentric()
    >>> galcen  # doctest: +FLOAT_CMP
    <Galactocentric Frame (galcen_coord=<ICRS Coordinate: (ra, dec) in deg
        (266.4051, -28.936175)>, galcen_distance=8.122 kpc, galcen_v_sun=(12.9, 245.6, 7.78) km / s, z_sun=20.8 pc, roll=0.0 deg)>
    >>> galcen.frame_attribute_references
    {'galcen_coord': 'http://adsabs.harvard.edu/abs/2004ApJ...616..872R',
     'galcen_distance': 'https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G',
     'galcen_v_sun': ['https://ui.adsabs.harvard.edu/abs/2018RNAAS...2..210D',
      'https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G',
      'https://ui.adsabs.harvard.edu/abs/2004ApJ...616..872R'],
     'z_sun': 'https://ui.adsabs.harvard.edu/abs/2019MNRAS.482.1417B'}

Note, however, if a frame parameter is set by the user, it is removed from the
reference list::

    >>> import astropy.units as u
    >>> galcen = coord.Galactocentric(z_sun=10*u.pc)
    >>> galcen.frame_attribute_references
    {'galcen_coord': 'http://adsabs.harvard.edu/abs/2004ApJ...616..872R',
     'galcen_distance': 'https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G',
     'galcen_v_sun': ['https://ui.adsabs.harvard.edu/abs/2018RNAAS...2..210D',
      'https://ui.adsabs.harvard.edu/abs/2018A%26A...615L..15G',
      'https://ui.adsabs.harvard.edu/abs/2004ApJ...616..872R']}

More information can be found in the documentation for the frame class:
`~astropy.coordinates.Galactocentric`.

Time improvements and changes
-----------------------------

New ``ymdhms`` Time format
^^^^^^^^^^^^^^^^^^^^^^^^^^

A new `~astropy.time.Time` format was added to allow convenient input and output
of times via year, month, day, hour, minute, second values.  For example::

  >>> from astropy.time import Time
  >>> t = Time({'year': 2015, 'month': 2, 'day': 3,
  ...           'hour': 12, 'minute': 13, 'second': 14.567})
  >>> t.iso
  '2015-02-03 12:13:14.567'
  >>> t.ymdhms.year
  2015


New context manager for plotting Time values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Matplotlib natively provides a mechanism for plotting dates and times on one
or both of the axes, as described in
`Date tick labels <https://matplotlib.org/3.1.0/gallery/text_labels_and_annotations/date.html>`_.
To make use of this, you can use the ``plot_date`` attribute of :class:`~astropy.time.Time` to get
values in the time system used by Matplotlib.

However, in many cases, you will probably want to have more control over the
precise scale and format to use for the tick labels, in which case you can make
use of the `~astropy.visualization.time_support` function which can be called
either directly or as a context manager, and after which :class:`~astropy.time.Time` objects can be
passed to matplotlib plotting functions. The axes are then automatically labeled
with times formatted using the :class:`~astropy.time.Time` class:

.. plot::
   :include-source:
   :context: reset

    >>> from matplotlib import pyplot as plt
    >>> from astropy.time import Time
    >>> from astropy.visualization import time_support
    >>> time_support(format='isot', scale='tai')  # doctest: +IGNORE_OUTPUT
    >>> plt.figure(figsize=(5,3))  # doctest: +IGNORE_OUTPUT
    >>> plt.plot(Time([52000, 53000, 54000], format='mjd'), [1.2, 3.3, 2.3])  # doctest: +IGNORE_OUTPUT

For more information, see :ref:`plotting-times`.

Support for parsing high-precision values with Time
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For numerical formats, :class:`~astropy.time.Time` can now be instantiated
from strings, quadruple precision numpy floats (if available on a given
platform), and :class:`Decimal` instances.  For instance, in the example below
one sees how in a string we can give full precision, while entering the same
number as a float gives precision loss::

    >>> from astropy.time import Time
    >>> t = Time('2450000.123456789012345', format='jd')
    >>> t - Time(2450000, .123456789012345, format='jd')
    <TimeDelta object: scale='tai' format='jd' value=0.0>
    >>> t - Time(2450000.123456789012345, format='jd')  # doctest: +FLOAT_CMP
    <TimeDelta object: scale='tai' format='jd' value=-1.6829138083096495e-10>

One can also output values as string, etc.::

    >>> t.to_value('jd', subfmt='str')
    '2450000.123456789012345'

Major improvements in compatibility of Quantity objects with Numpy functions
----------------------------------------------------------------------------

While :class:`~astropy.units.Quantity` objects have worked well in arithmetic
operations via numpy's "universal functions" (ufuncs), for other numpy
functions it has been a bit hit and miss.  For instance, units would be lost
when trying to concatenate quantities, making histogrammes, or in functions
such as `numpy.where`.

For numpy version 1.17 and later, however, it is possible to override the
behaviour of numpy functions, and this is used in astropy 4.0 to make
essentially all functions work as expected with quantities.  If a numpy
function does not work as expected, it is now a bug that we can fix!

Two simple examples:

    >>> import numpy as np
    >>> from astropy import units as u
    >>> np.where([True, False, False], [1., 2., 3.]*u.m, 1.*u.cm)
    <Quantity [1.  , 0.01, 0.01] m>
    >>> np.hstack(([1., 2., 3.]*u.m, 1.*u.cm))
    <Quantity [1.  , 2.  , 3.  , 0.01] m>

.. note:: for numpy 1.16, one can get the same behaviour by setting
          environment variable ``NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1``.
          For details, see
          `NEP 18 <https://numpy.org/neps/nep-0018-array-function-protocol.html>`_

Plotting 1-d profile plots with WCSAxes
---------------------------------------


Default labelling with WCSAxes
------------------------------


New function to fit WCS to pairs of pixel/world coordinates
-----------------------------------------------------------


Support for WCS transformations between pixel and Time values
-------------------------------------------------------------

The :meth:`WCS.world_to_pixel <astropy.wcs.WCS.world_to_pixel>` and
:meth:`WCS.pixel_to_world <astropy.wcs.WCS.pixel_to_world>` methods can now
take and return :class:`~astropy.time.Time` objects for WCS transforamtions
that involve time::

    >>> from astropy.io import fits
    >>> from astropy.wcs import WCS
    >>> header = fits.Header()
    >>> header['CTYPE1'] = 'TIME'
    >>> header['CDELT1'] = 86400.
    >>> header['MJDREF'] = 58788.
    >>> wcs = WCS(header)
    >>> wcs.pixel_to_world([2, 3, 4])
    <Time object: scale='utc' format='mjd' value=[58791. 58792. 58793.]>
    >>> wcs.world_to_pixel(Time('2019-11-02T10:30:22'))
    array(0.43775463)

Improvements to folding for time series
---------------------------------------

The :meth:`TimeSeries.fold <astropy.timeseries.TimeSeries.fold>` method now
includes more options for controlling the resulting phase values. First, the
``midpoint_epoch`` argument has been renamed to ``epoch_time`` so as to be more
general, and the ``epoch_phase`` can be used to specify the phase at which the
epoch is given. In addition, a new ``wrap_phase`` argument can be used to
specify at what phase to wrap - for example if this is set to half the period,
the resulting phase will go from minus half the period to half the period,
whereas if it is set to the period the resulting phase will go from zero to the
period::

    >>> from astropy import units as u
    >>> from astropy.timeseries import TimeSeries
    >>> ts = TimeSeries(time_start='2019-11-01T00:00:00', time_delta=0.3 * u.day,
    ...                 n_samples=10)
    >>> tf1 = ts.fold(1 * u.day, epoch_time='2019-11-01T12:00:00',
    ...               wrap_phase=1 * u.day)
    >>> tf1  # doctest: +FLOAT_CMP
    <TimeSeries length=10>
            time
           object
    -------------------
                    0.5
                    0.8
                    0.1
                    0.4
                    0.7
                    0.0
                    0.3
                    0.6
                    0.9
                    0.2

Finally, the new ``normalize_phase`` keyword argument can be used to
specify whether the final phase should be a relative time or whether it should
be normalized to a dimensionless value in the range 0 to 1::

    >>> tf2 = ts.fold(1 * u.day, epoch_time='2019-11-01T12:00:00',
    ...               normalize_phase=True)
    >>> tf2  # doctest: +FLOAT_CMP
    <TimeSeries length=10>
            time
    <BLANKLINE>
          float64
    -------------------
                   -0.5
                   -0.2
                    0.1
                    0.4
                   -0.3
                    0.0
                    0.3
                   -0.4
                   -0.1
                    0.2

Support for surface brightnesses in spectral_density equivalencies
------------------------------------------------------------------


New cache import/export utilities
---------------------------------


Table improvements and changes
------------------------------

The `astropy.table <https://docs.astropy.org/en/v4.0.x/table/index.html>`_
sub-package saw a lot of development for the 4.0 release and you are encouraged
to see the `Full Changelog for 4.0
<https://docs.astropy.org/en/v4.0.x/changelog.html>`_ for details.  The
highlights are discussed below.

Performance
^^^^^^^^^^^

A number of performance improvements were introduced in version 4.0 that can
substantially improve the speed of ``Table`` manipulations.

A key area was the handling of replacing and adding columns, which is now 2 to
10 times faster in common cases. The implementation was changed so that the time
for replacing or adding is independent of the number of existing columns (like a
``dict``). This means one can now *efficiently* build a table from scratch by
creating an empty table and then adding columns one at a time.

Another improvement was in the performance of table and column slicing. In
addition to internal implementation changes, there was a change to reduce
unnecessary copy and deepcopy of table and column ``meta`` attributes. In
particular table or column slices will now get a shallow key-only copy of the
metadata instead of a deep copy.

Table row access speed was improved by a factor of a few, and getting the length
of a table is now typically 3 to 10 times faster. A new method
`~astropy.table.Table.iterrows` was added to make row-wise iteration even faster
for the common case of only needing a subset of the available columns::

  >>> from astropy.table.table_helpers import simple_table
  >>> t = simple_table(size=2, cols=10)
  >>> print(t)
   a   b   c   d   e   f   g   h   i   j
  --- --- --- --- --- --- --- --- --- ---
    1 1.0   c   4 4.0   f   7 7.0   i  10
    2 2.0   d   5 5.0   g   8 8.0   j  11
  >>> for a, f in t.iterrows('a', 'f'):
  ...     print(a, f)
  ...
  1 f
  2 g

New methods and options
^^^^^^^^^^^^^^^^^^^^^^^

A new method `~astropy.table.Table.dstack` was added to allow depth-wise stacking
of tables to turn a list of similar tables into a single "3-d" table with
(rows, columns, depth).

A new method to compare tables `~astropy.table.Table.values_equal` was added
to allow element-wise comparison of a table to either another table, a list of
values, or a single value. This returns a new ``Table`` with the boolean result
of the comparisons.

The `~astropy.table.Table.join` operation now supports cartesian joins,
enumerating all possible combinations of the left and right table rows.

A `~astropy.table.Table` can now be initialized with a with a list of dict where
the dict keys are not the same in every row. The table column names are the set
of all keys found in the input data, and any missing key/value pairs are turned
into missing data in the table.

The `~astropy.table.Table.add_column` and `~astropy.table.Table.add_columns`
methods can now accept any object(s) which can be converted or broadcasted
to a valid column for the table.  Previously these methods required a valid
`~astropy.table.Column` or mixin column object.

API changes
^^^^^^^^^^^

The handling of masked columns in tables has changed in a way that may impact
program behavior. Now a :class:`~astropy.table.Table` object with
``masked=False`` may contain both ``Column`` and ``MaskedColumn`` objects, and
adding a masked column or row to a table no longer "upgrades" the table and all
other columns to masked. This means that tables with masked data which are read
via ``Table.read()`` will now always have ``masked=False``, though specific
columns will be masked as needed. The same applies to the output of table
operations like `~astropy.table.Table.join`, `~astropy.table.Table.vstack`, and
`~astropy.table.Table.hstack`. Two new table properties ``has_masked_columns``
and ``has_masked_values`` were added. See the `Masking change in astropy 4.0
<https://docs.astropy.org/en/v4.0.x/table/masking.html#masking-change-in-astropy-4-0>`_
section for details.

As noted earlier, the handling of table and column ``meta`` attributes has
changed and one no longer gets deep copies in most cases.

Improved handling of leap second updates
----------------------------------------

Astropy now automatically checks for and applies new leap seconds the first
time a :class:`~astropy.time.Time` is instantiated.  This is done with the new
:class:`~astropy.utils.iers.LeapSecond` class, which can, in the hopefully
unlikely case it is needed, also be used directly.

API changes in astropy.modeling
-------------------------------

.. changes for compound models::

A number of significant changes have been made to modeling API as a result
of reworking how parameters and compound models work.

* It is no longer possible to create compound model classes (as opposed
  to compound model instances).

* Parameters now hold their values directly with the consequence that compound models
  share the same parameter instances as the constituent model they are constructed
  from (previously the values were copied and changes to one or the other had no
  effect on the corresponding model).

* In compound models, the constituent models are references, not copies
  (if copies are desired, an explicit copy() should be used in the compound
  model expression).

There are other, more minor, changes to the API that are detailed in :ref:`changes_for_4`

* ``inputs`` and ``outputs`` were deprecated as class variables and are instance variables,
  while ``n_inputs`` and ``n_outputs`` are now class variables. As a result ``inputs`` and
  ``outputs`` of a model can be renamed.

* Assigning slices of the model parameter array does not automatically get
  reflected in parameter values

* Previously it was possible to use arbitrary slices on compound models (which had
  the possibility of returning submodes with entirely different meanings than they
  had in the original compound model). Now only a restricted set of slices is permitted.

* Use of “imputed” units is much more restricted. Previously these could end up with
  unexpected units being assigned.

* Many private methods have been added, changed, or deleted.

A large reorganization has been made of the modeling documentation to make it easier to find relevant topics.

API changes in astropy.uncertainty
----------------------------------

For the experimental :class:`~astropy.uncertainty.Distribution` class, the
earlier ``pdf_mean``, ``pdf_var``, etc., properties were turned into methods,
both for consistency with the numpy methods that are used underneath, and to
allow one to pass on parameters (such as the degrees of freedom ``ddof`` for
:meth:`~astropy.uncertainty.Distribution.pdf_var`).

While the module remains experimental, and further enhancements and
refactoring are planned, we do not foresee any further significant changes in
the API.


Full change log
===============

To see a detailed list of all changes in version v4.0, including changes in
API, please see the :ref:`changelog`.


Renamed/removed functionality
=============================
